{"ast":null,"code":"// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\nexport function bfs(grid,startNode,finishNode){var visitedNodesInOrder=[];var nextNodesStack=[startNode];while(nextNodesStack.length){var currentNode=nextNodesStack.shift();if(currentNode===finishNode)return visitedNodesInOrder;if(!currentNode.isWall&&(currentNode.isStart||!currentNode.isVisited)){currentNode.isVisited=true;visitedNodesInOrder.push(currentNode);var col=currentNode.col,row=currentNode.row;var unvisitedNeighbors=getUnvisitedNeighbors(currentNode,grid);var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=unvisitedNeighbors[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var neighbor=_step.value;if(neighbor.isWall)continue;neighbor.distance=currentNode.distance+1;nextNodesStack.push(neighbor);neighbor.previousNode=currentNode;}}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(!_iteratorNormalCompletion&&_iterator.return!=null){_iterator.return();}}finally{if(_didIteratorError){throw _iteratorError;}}}}}return visitedNodesInOrder;}function getUnvisitedNeighbors(node,grid){var neighbors=[];var col=node.col,row=node.row;if(row>0)neighbors.push(grid[row-1][col]);if(row<grid.length-1)neighbors.push(grid[row+1][col]);if(col>0)neighbors.push(grid[row][col-1]);if(col<grid[0].length-1)neighbors.push(grid[row][col+1]);return neighbors.filter(function(neighbor){return!neighbor.isVisited;});}","map":{"version":3,"sources":["/home/siddhant/Documents/CODES/summer proj/PathFindingVisualizer/src/algorithms/bfs.js"],"names":["bfs","grid","startNode","finishNode","visitedNodesInOrder","nextNodesStack","length","currentNode","shift","isWall","isStart","isVisited","push","col","row","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","distance","previousNode","node","neighbors","filter"],"mappings":"AAAA;AACA;AACA;AAEA,MAAO,SAASA,CAAAA,GAAT,CAAaC,IAAb,CAAmBC,SAAnB,CAA8BC,UAA9B,CAA0C,CAC/C,GAAMC,CAAAA,mBAAmB,CAAG,EAA5B,CACA,GAAIC,CAAAA,cAAc,CAAG,CAACH,SAAD,CAArB,CACA,MAAOG,cAAc,CAACC,MAAtB,CAA8B,CAC5B,GAAMC,CAAAA,WAAW,CAAGF,cAAc,CAACG,KAAf,EAApB,CACA,GAAID,WAAW,GAAKJ,UAApB,CAAgC,MAAOC,CAAAA,mBAAP,CAEhC,GACE,CAACG,WAAW,CAACE,MAAb,GACCF,WAAW,CAACG,OAAZ,EAAuB,CAACH,WAAW,CAACI,SADrC,CADF,CAGE,CACAJ,WAAW,CAACI,SAAZ,CAAwB,IAAxB,CACAP,mBAAmB,CAACQ,IAApB,CAAyBL,WAAzB,EAFA,GAGOM,CAAAA,GAHP,CAGmBN,WAHnB,CAGOM,GAHP,CAGYC,GAHZ,CAGmBP,WAHnB,CAGYO,GAHZ,CAIA,GAAMC,CAAAA,kBAAkB,CAAGC,qBAAqB,CAACT,WAAD,CAAcN,IAAd,CAAhD,CAJA,gGAKA,kBAAuBc,kBAAvB,oHAA2C,IAAhCE,CAAAA,QAAgC,aACzC,GAAGA,QAAQ,CAACR,MAAZ,CAAoB,SACpBQ,QAAQ,CAACC,QAAT,CAAoBX,WAAW,CAACW,QAAZ,CAAuB,CAA3C,CACAb,cAAc,CAACO,IAAf,CAAoBK,QAApB,EACAA,QAAQ,CAACE,YAAT,CAAwBZ,WAAxB,CACD,CAVD,qMAWD,CACF,CACD,MAAOH,CAAAA,mBAAP,CACD,CAED,QAASY,CAAAA,qBAAT,CAA+BI,IAA/B,CAAqCnB,IAArC,CAA2C,CACzC,GAAMoB,CAAAA,SAAS,CAAG,EAAlB,CADyC,GAElCR,CAAAA,GAFkC,CAEtBO,IAFsB,CAElCP,GAFkC,CAE7BC,GAF6B,CAEtBM,IAFsB,CAE7BN,GAF6B,CAGzC,GAAIA,GAAG,CAAG,CAAV,CAAaO,SAAS,CAACT,IAAV,CAAeX,IAAI,CAACa,GAAG,CAAG,CAAP,CAAJ,CAAcD,GAAd,CAAf,EACb,GAAIC,GAAG,CAAGb,IAAI,CAACK,MAAL,CAAc,CAAxB,CAA2Be,SAAS,CAACT,IAAV,CAAeX,IAAI,CAACa,GAAG,CAAG,CAAP,CAAJ,CAAcD,GAAd,CAAf,EAC3B,GAAIA,GAAG,CAAG,CAAV,CAAaQ,SAAS,CAACT,IAAV,CAAeX,IAAI,CAACa,GAAD,CAAJ,CAAUD,GAAG,CAAG,CAAhB,CAAf,EACb,GAAIA,GAAG,CAAGZ,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAAR,CAAiB,CAA3B,CAA8Be,SAAS,CAACT,IAAV,CAAeX,IAAI,CAACa,GAAD,CAAJ,CAAUD,GAAG,CAAG,CAAhB,CAAf,EAC9B,MAAOQ,CAAAA,SAAS,CAACC,MAAV,CAAiB,SAAAL,QAAQ,QAAI,CAACA,QAAQ,CAACN,SAAd,EAAzB,CAAP,CACD","sourcesContent":["// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function bfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  let nextNodesStack = [startNode];\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.shift();\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n      const {col, row} = currentNode;\r\n      const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\r\n      for (const neighbor of unvisitedNeighbors) {\r\n        if(neighbor.isWall) continue;\r\n        neighbor.distance = currentNode.distance + 1;\r\n        nextNodesStack.push(neighbor);\r\n        neighbor.previousNode = currentNode;\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}