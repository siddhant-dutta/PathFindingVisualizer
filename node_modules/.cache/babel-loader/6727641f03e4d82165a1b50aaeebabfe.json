{"ast":null,"code":"// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid,startNode,finishNode){var visitedNodesInOrder=[];startNode.distance=0;var unvisitedNodes=getAllNodes(grid);// Q: different from using grid or slice of grid???\nwhile(unvisitedNodes.length){sortNodesByDistance(unvisitedNodes);var closestNode=unvisitedNodes.shift();// If we encounter a wall, we skip it.\nif(!closestNode.isWall){// If the closest node is at a distance of infinity,\n// we must be trapped and should stop.\nif(closestNode.distance===Infinity)return visitedNodesInOrder;closestNode.isVisited=true;visitedNodesInOrder.push(closestNode);if(closestNode===finishNode)return visitedNodesInOrder;updateUnvisitedNeighbors(closestNode,grid);}}return visitedNodesInOrder;}function getAllNodes(grid){var nodes=[];var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=grid[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var row=_step.value;var _iteratorNormalCompletion2=true;var _didIteratorError2=false;var _iteratorError2=undefined;try{for(var _iterator2=row[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){var node=_step2.value;nodes.push(node);}}catch(err){_didIteratorError2=true;_iteratorError2=err;}finally{try{if(!_iteratorNormalCompletion2&&_iterator2.return!=null){_iterator2.return();}}finally{if(_didIteratorError2){throw _iteratorError2;}}}}}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(!_iteratorNormalCompletion&&_iterator.return!=null){_iterator.return();}}finally{if(_didIteratorError){throw _iteratorError;}}}return nodes;}function sortNodesByDistance(unvisitedNodes){unvisitedNodes.sort(function(nodeA,nodeB){return nodeA.distance-nodeB.distance;});}function updateUnvisitedNeighbors(node,grid){var unvisitedNeighbors=getUnvisitedNeighbors(node,grid);var _iteratorNormalCompletion3=true;var _didIteratorError3=false;var _iteratorError3=undefined;try{for(var _iterator3=unvisitedNeighbors[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=true){var neighbor=_step3.value;if(neighbor.isWall)continue;neighbor.distance=node.distance+1;neighbor.previousNode=node;}}catch(err){_didIteratorError3=true;_iteratorError3=err;}finally{try{if(!_iteratorNormalCompletion3&&_iterator3.return!=null){_iterator3.return();}}finally{if(_didIteratorError3){throw _iteratorError3;}}}}function getUnvisitedNeighbors(node,grid){var neighbors=[];var col=node.col,row=node.row;if(row>0)neighbors.push(grid[row-1][col]);if(row<grid.length-1)neighbors.push(grid[row+1][col]);if(col>0)neighbors.push(grid[row][col-1]);if(col<grid[0].length-1)neighbors.push(grid[row][col+1]);return neighbors.filter(function(neighbor){return!neighbor.isVisited;});}","map":{"version":3,"sources":["/home/siddhant/Documents/CODES/summer proj/PathFindingVisualizer/src/algorithms/dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbors","nodes","row","node","sort","nodeA","nodeB","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","filter"],"mappings":"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","sourcesContent":["// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid); // Q: different from using grid or slice of grid???\r\n\r\n  while (unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (!closestNode.isWall) {\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    if(neighbor.isWall) continue;\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}"]},"metadata":{},"sourceType":"module"}