{"ast":null,"code":"// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\nexport function bfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  let nextNodesStack = [startNode];\n\n  while (nextNodesStack.length) {\n    const currentNode = nextNodesStack.shift();\n    if (currentNode === finishNode) return visitedNodesInOrder;\n\n    if (!currentNode.isWall && (currentNode.isStart || !currentNode.isVisited)) {\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n      const col = currentNode.col,\n            row = currentNode.row;\n      const unvisitedNeighbors = getUnvisitedNeighbors(currentnode, grid);\n\n      for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = currentnode.distance + 1;\n        nextNodesStack.push(neighbor);\n        neighbor.previousNode = currentNode;\n      }\n    }\n  } // return visitedNodesInOrder;\n\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const col = node.col,\n        row = node.row;\n  if (!grid[row - 1][col].isWall && row > 0) neighbors.push(grid[row - 1][col]);\n  if (!grid[row + 1][col].isWall && row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (!grid[row][col - 1].isWall && col > 0) neighbors.push(grid[row][col - 1]);\n  if (!grid[row][col + 1].isWall && col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}","map":{"version":3,"sources":["/home/siddhant/Documents/CODES/pathFinderVisualizer-master/src/algorithms/bfs.js"],"names":["bfs","grid","startNode","finishNode","visitedNodesInOrder","nextNodesStack","length","currentNode","shift","isWall","isStart","isVisited","push","col","row","unvisitedNeighbors","getUnvisitedNeighbors","currentnode","neighbor","distance","previousNode","node","neighbors","filter"],"mappings":"AAAA;AACA;AACA;AAEA,OAAO,SAASA,GAAT,CAAaC,IAAb,EAAmBC,SAAnB,EAA8BC,UAA9B,EAA0C;AAC/C,QAAMC,mBAAmB,GAAG,EAA5B;AACA,MAAIC,cAAc,GAAG,CAACH,SAAD,CAArB;;AACA,SAAOG,cAAc,CAACC,MAAtB,EAA8B;AAC5B,UAAMC,WAAW,GAAGF,cAAc,CAACG,KAAf,EAApB;AACA,QAAID,WAAW,KAAKJ,UAApB,EAAgC,OAAOC,mBAAP;;AAEhC,QACE,CAACG,WAAW,CAACE,MAAb,KACCF,WAAW,CAACG,OAAZ,IAAuB,CAACH,WAAW,CAACI,SADrC,CADF,EAGE;AACAJ,MAAAA,WAAW,CAACI,SAAZ,GAAwB,IAAxB;AACAP,MAAAA,mBAAmB,CAACQ,IAApB,CAAyBL,WAAzB;AAFA,YAGOM,GAHP,GAGmBN,WAHnB,CAGOM,GAHP;AAAA,YAGYC,GAHZ,GAGmBP,WAHnB,CAGYO,GAHZ;AAIA,YAAMC,kBAAkB,GAAGC,qBAAqB,CAACC,WAAD,EAAchB,IAAd,CAAhD;;AACA,WAAK,MAAMiB,QAAX,IAAuBH,kBAAvB,EAA2C;AACzCG,QAAAA,QAAQ,CAACC,QAAT,GAAoBF,WAAW,CAACE,QAAZ,GAAuB,CAA3C;AACAd,QAAAA,cAAc,CAACO,IAAf,CAAoBM,QAApB;AACAA,QAAAA,QAAQ,CAACE,YAAT,GAAwBb,WAAxB;AACD;AACF;AACF,GArB8C,CAsB/C;;AACD;;AAED,SAASS,qBAAT,CAA+BK,IAA/B,EAAqCpB,IAArC,EAA2C;AACzC,QAAMqB,SAAS,GAAG,EAAlB;AADyC,QAElCT,GAFkC,GAEtBQ,IAFsB,CAElCR,GAFkC;AAAA,QAE7BC,GAF6B,GAEtBO,IAFsB,CAE7BP,GAF6B;AAGzC,MAAI,CAACb,IAAI,CAACa,GAAG,GAAG,CAAP,CAAJ,CAAcD,GAAd,EAAmBJ,MAApB,IAA8BK,GAAG,GAAG,CAAxC,EAA2CQ,SAAS,CAACV,IAAV,CAAeX,IAAI,CAACa,GAAG,GAAG,CAAP,CAAJ,CAAcD,GAAd,CAAf;AAC3C,MAAI,CAACZ,IAAI,CAACa,GAAG,GAAC,CAAL,CAAJ,CAAYD,GAAZ,EAAiBJ,MAAlB,IAA4BK,GAAG,GAAGb,IAAI,CAACK,MAAL,GAAc,CAApD,EAAuDgB,SAAS,CAACV,IAAV,CAAeX,IAAI,CAACa,GAAG,GAAG,CAAP,CAAJ,CAAcD,GAAd,CAAf;AACvD,MAAI,CAACZ,IAAI,CAACa,GAAD,CAAJ,CAAUD,GAAG,GAAG,CAAhB,EAAmBJ,MAApB,IAA8BI,GAAG,GAAG,CAAxC,EAA2CS,SAAS,CAACV,IAAV,CAAeX,IAAI,CAACa,GAAD,CAAJ,CAAUD,GAAG,GAAG,CAAhB,CAAf;AAC3C,MAAI,CAACZ,IAAI,CAACa,GAAD,CAAJ,CAAUD,GAAG,GAAG,CAAhB,EAAmBJ,MAApB,IAA8BI,GAAG,GAAGZ,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAAR,GAAiB,CAAzD,EAA4DgB,SAAS,CAACV,IAAV,CAAeX,IAAI,CAACa,GAAD,CAAJ,CAAUD,GAAG,GAAG,CAAhB,CAAf;AAC5D,SAAOS,SAAS,CAACC,MAAV,CAAiBL,QAAQ,IAAI,CAACA,QAAQ,CAACP,SAAvC,CAAP;AACD","sourcesContent":["// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function bfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  let nextNodesStack = [startNode];\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.shift();\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n      const {col, row} = currentNode;\r\n      const unvisitedNeighbors = getUnvisitedNeighbors(currentnode, grid);\r\n      for (const neighbor of unvisitedNeighbors) {\r\n        neighbor.distance = currentnode.distance + 1;\r\n        nextNodesStack.push(neighbor);\r\n        neighbor.previousNode = currentNode;\r\n      }\r\n    }\r\n  }\r\n  // return visitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (!grid[row - 1][col].isWall && row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (!grid[row+1][col].isWall && row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (!grid[row][col - 1].isWall && col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (!grid[row][col + 1].isWall && col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}